<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="1:n key-value store for C++ and Java">
    <meta name="author" content="Martin Trenkmann">
    <link rel="icon" href="../favicon.ico">
    <title>Multimap</title>
    
    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
    
    <!-- Bootstrap -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
    
    <!-- highlight.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/googlecode.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    
    <!-- Fonts -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Faster+One">
    <!--
    <link rel="stylesheet" href="https://code.cdn.mozilla.net/fonts/fira.css">
    Firefox Console: The stylesheet https://code.cdn.mozilla.net/fonts/fira.css
    was not loaded because its MIME type, "application/octet-stream", is not "text/css".
    -->
    <link rel="stylesheet" href="../fonts/fira.css">
    
    <!-- Customized Bootstrap style -->
    <link rel="stylesheet" href="../bootstrap-multimap.css">
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <script>
      function nbsp(n) {
        for (var i = 0; i < n; ++i) {
          document.write("&nbsp;");
        }
      }
      function year() {
        document.write(new Date().getFullYear());
      }
    </script>
  </head>
  
  <body data-spy="scroll" data-target="#multimap-sidebar" data-offset="50">
    <div id="main">
      <nav class="navbar navbar-inverse navbar-static-top">
        <div class="container">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#multimap-navbar-collapse" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <span class="navbar-brand">Multimap</span>
        </div>
        <div class="container">
          <div class="collapse navbar-collapse" id="multimap-navbar-collapse">
            <ul class="nav navbar-nav">
              
                
                  <li >
                    <a href="..">Home</a>
                  </li>
                
              
                
                  <li >
                    <a href="../overview/">Overview</a>
                  </li>
                
              
                
                  <li class="dropdown ">
                    <a href="#">Tutorials <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li class="dropdown-header">C++</li>
                          
                            <li >
                              <a href="../cppbasics/">Basics</a>
                            </li>
                          
                        
                      
                        
                          <li class="dropdown-header">Java</li>
                          
                            <li >
                              <a href="../javabasics/">Basics</a>
                            </li>
                          
                        
                      
                    </ul>
                  </li>
                
              
                
                  <li class="dropdown  active ">
                    <a href="#">Reference <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li  class="active" >
                            <a href="./">C++ Reference</a>
                          </li>
                        
                      
                        
                          <li >
                            <a href="../javareference/">Java Reference</a>
                          </li>
                        
                      
                    </ul>
                  </li>
                
              
                
                  <li class="dropdown ">
                    <a href="#">Installation <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li >
                            <a href="../installation-linux/">GNU/Linux</a>
                          </li>
                        
                      
                        
                          <li >
                            <a href="../installation-osx/">OS X</a>
                          </li>
                        
                      
                    </ul>
                  </li>
                
              
              
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">GitHub <span class="caret"></span></a>
                <ul class="dropdown-menu">
                  <li><a href="https://github.com/mtrenkmann/multimap">View on GitHub</a></li>
                  <li><a href="https://github.com/mtrenkmann/multimap/issues">Create an Issue</a></li>
                  <li><a href="https://github.com/mtrenkmann/multimap/subscription">Watch this Project</a></li>
                </ul>
              </li>
            </ul>
          </div>
        </div>
      </nav>
      
      
        <div class="container">
          <div class="row">
            
              <div class="col-md-9" role="main">
                <h2 id="byteshpp">Bytes.hpp</h2>
<pre><code class="cpp">#include &lt;multimap/Bytes.hpp&gt;
namespace multimap
</code></pre>

<h3 id="class-bytes">class Bytes</h3>
<p>This class is a thin wrapper for raw binary data. It just holds a pointer to data together with its size (number of bytes). It is used to represent keys and values that are put into or gotten from a map. An object of this class never deep copies the data it is constructed from, nor does it take any ownership of the data. It is really just a helper for providing a generic interface.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Member functions</th>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>Bytes()</code>
   <div>Creates an empty byte array. <a href="#bytes-bytes">more...</a><div>
  </td>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>Bytes(const char * cstr)</code>
   <div>Creates a byte array from a null-terminated C-string. <a href="#bytes-bytes-cstr">more...</a><div>
  </td>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>Bytes(const std::string & str)</code>
   <div>Creates a byte array from a standard string. <a href="#bytes-bytes-str">more...</a><div>
  </td>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>Bytes(const void * data, size_t size)</code>
   <div>Creates a byte array from arbitrary data. <a href="#bytes-bytes-data-size">more...</a><div>
  </td>
 </tr>
 <tr>
  <td><code>const char *</code></td>
  <td>
   <code>data() const</code>
   <div>Returns a read-only pointer to the wrapped data.<div>
  </td>
 </tr>
 <tr>
  <td><code>size_t</code></td>
  <td>
   <code>size() const</code>
   <div>Returns the number of bytes wrapped.<div>
  </td>
 </tr>
 <tr>
  <td><code>const char *</code></td>
  <td>
   <code>begin() const</code>
   <div>Returns a read-only pointer to the beginning of the wrapped data.<div>
  </td>
 </tr>
 <tr>
  <td><code>const char *</code></td>
  <td>
   <code>end() const</code>
   <div>Returns a past-the-end pointer to the wrapped data.<div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>empty() const</code>
   <div>Tells whether the byte array is empty. <a href="#bytes-empty">more...</a><div>
  </td>
 </tr>
 <tr>
  <td><code>void</code></td>
  <td>
   <code>clear()</code>
   <div>Let this byte array point to an empty array. <a href="#bytes-clear">more...</a><div>
  </td>
 </tr>
 <tr>
  <td><code>std::string</code></td>
  <td>
   <code>toString() const</code>
   <div>Returns a string which contains a copy of the wrapped data. <a href="#bytes-tostring">more...</a><div>
  </td>
 </tr>
 <tr>
  <th colspan="2">Non-member functions</th>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>operator==(const Bytes & lhs, const Bytes & rhs)</code>
   <div>Compares two byte arrays for equality. <a href="#operator-eq">more...</a><div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>operator!=(const Bytes & lhs, const Bytes & rhs)</code>
   <div>Returns the inverse of the previous function.<div>
  </td>
 </tr>
 <tr>
  <th colspan="2">Helper classes</th>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>std::hash&lt;Bytes&gt;</code>
   <div>Hash support for class Bytes.<div>
  </td>
 </tr>
</tbody>
</table>

<div class="reference-more">
 <h4 id="bytes-bytes"><code>Bytes::Bytes()</code></h4>
 <p>Creates an empty byte array.</p>
 <p><span class="ensures" /></p>
 <ul>
  <li><code>data() != nullptr</code></li>
  <li><code>size() == 0</code></li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="bytes-bytes-cstr"><code>Bytes::Bytes(const char * cstr)</code></h4>
 <p>Creates a byte array from a null-terminated C-string. This constructor allows implicit conversion.</p>
 <p><span class="ensures" /></p>
 <ul>
  <li><code>data() == cstr</code></li>
  <li><code>size() == std::strlen(cstr)</code></li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="bytes-bytes-str"><code>Bytes::Bytes(const std::string & str)</code></h4>
 <p>Creates a byte array from a standard string. This constructor allows implicit conversion.</p>
 <p><span class="ensures" /></p>
 <ul>
  <li><code>data() == str.data()</code></li>
  <li><code>size() == str.size()</code></li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="bytes-bytes-data-size"><code>Bytes::Bytes(const void * data, size_t size)</code></h4>
 <p>Creates a byte array from arbitrary data.</p>
 <p><span class="ensures" /></p>
 <ul>
  <li><code>data() == data</code></li>
  <li><code>size() == size</code></li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="bytes-empty"><code>bool Bytes::empty() const</code></h4>
 <p>Tells whether the byte array is empty. Returns <code>true</code> if the number of bytes is zero, <code>false</code> otherwise.</p>
</div>

<div class="reference-more">
 <h4 id="bytes-clear"><code>void Bytes::clear()</code></h4>
 <p>Let this byte array point to an empty array.</p>
 <p><span class="ensures" /></p>
 <ul>
  <li><code>data() != nullptr</code></li>
  <li><code>size() == 0</code></li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="bytes-tostring"><code>std::string toString() const</code></h4>
 <p>Returns a string which contains a copy of the wrapped data. <code>std::string</code> is used as a convenient byte buffer and may contain bytes that are not printable or even null-bytes.</p>
 <p><span class="ensures" /></p>
 <ul>
  <li><code>data() != return_value.data()</code></li>
  <li><code>size() == return_value.size()</code></li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="operator-eq"><code>bool operator==(const Bytes & lhs, const Bytes & rhs)</code></h4>
 <p>Compares two byte arrays for equality. Two byte arrays are equal, if they wrap the same number of bytes, and which are equal after byte-wise comparison.</p>
</div>

<h2 id="iteratorhpp">Iterator.hpp</h2>
<pre><code class="cpp">#include &lt;multimap/Iterator.hpp&gt;
namespace multimap
</code></pre>

<h3 id="class-iterator">class Iterator</h3>
<p>This is an abstract base class or interface that represents an iterator for reading a list of values.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Member functions</th>
 </tr>
 <tr>
  <td><code>virtual uint32_t</code></td>
  <td>
   <code>available() const = 0</code>
   <div>Returns the remaining number of values to be iterated.<div>
  </td>
 </tr>
 <tr>
  <td><code>virtual bool</code></td>
  <td>
   <code>hasNext() const = 0</code>
   <div>Returns true if the iterator has more values, false otherwise.<div>
  </td>
 </tr>
 <tr>
  <td><code>virtual Bytes</code></td>
  <td>
   <code>next() = 0</code>
   <div>Returns the next value from the underlying list and moves the iterator once forward. <a href="#iterator-next">more...</a><div>
  </td>
 </tr>
 <tr>
  <td><code>virtual Bytes</code></td>
  <td>
   <code>peekNext() = 0</code>
   <div>Same as before, but does not move the iterator once forward.<div>
  </td>
 </tr>
 <tr>
  <th colspan="2">Static member functions</th>
 </tr>
 <tr>
  <td><code>std::unique_ptr&lt;Iterator&gt;</code></td>
  <td>
   <code>newEmptyInstance()</code>
   <div>Creates a new iterator that has no values to deliver. Its purpose is to model an empty result in situations where a nullptr is not desirable, usually to avoid an extra null-check.<div>
  </td>
 </tr>
</tbody>
</table>

<div class="reference-more">
 <h4 id="iterator-next">
  <code>virtual <a href="#class-bytes">Bytes</a> Iterator::next() = 0</code>
 </h4>
 <p>Returns the next value from the underlying list and moves the iterator once forward. The returned <a href="#class-bytes">Bytes</a> object points to data managed by the iterator and is only valid for read access until the next call of this method. Reading from invalid data is undefined behavior. A deep copy of the value can be created by either calling its <a href="#bytes-tostring">toString()</a> method or <a href="http://en.cppreference.com/w/cpp/string/byte/memcpy">std::memcpy()</a> its data into another buffer.</p>
 <p><span class="requires" /><code>hasNext()</code> yields true.</p>
</div>

<h2 id="maphpp">Map.hpp</h2>
<pre><code class="cpp">#include &lt;multimap/Map.hpp&gt;
namespace multimap
</code></pre>

<h3 id="class-map">class Map</h3>
<p>This class implements a 1:n key-value store where each key is associated with a list of values. When putting a key-value pair into the map, the value is appended to the end of the list that is associated with the key. If no such key-list pair already exist, it will be created. Looking up a key returns a read-only iterator for the associated list. If the key does not exist, the list is considered to be empty and the returned iterator has no values to deliver. From a user's point of view there is no distinction between an empty list and a non-existing list.</p>
<p>Map also supports removing or replacing values. When a value is removed, it will be marked as such for the moment making it invisible for subsequent iterations. Running an <a href="#map-optimize">optimze</a> operation removes the data physically. The replace operation is implemented as a remove of the old value followed by an insert/put of the new value. In other words, the replacement is not in-place, but the new value is always the last value in the corresponding list. To restore a certain order an optimze operation can be run as well. However, optimization is considered a less frequent, more administrative task.</p>
<p>The class is designed to be a fast and mutable. For that reason, this class holds the entire key set in memory. This is also true for keys that were removed from the map at runtime. In addition, each key is associated with a write buffer which altogether contribute a lot to the total memory footprint of the map. Therefore, the number of keys to be put is limited by the amount of available memory. However, this simple design was intended in favour of performance, especially due to the fact that memory is relatively cheap and (server) machines are equipped with more and more of it.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Member types</th>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>Limits</code>
   <div>Provides static methods to ask for maximum key and value sizes. <a href="#struct-maplimits">more...</a><div>
  </td>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>Options</code>
   <div>Pure data holder used to configure an instance of Map. <a href="#struct-mapoptions">more...</a><div>
  </td>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>Stats</code>
   <div>Pure data holder that reports statistics about an instance of Map. <a href="#struct-mapstats">more...</a><div>
  </td>
 </tr>
 <tr>
  <th colspan="2">Member functions</th>
 </tr>
 <tr>
  <td><code>explicit</code></td>
  <td>
   <code>Map(const boost::filesystem::path & directory)</code>
   <div>Opens an already existing map located in directory. <a href="#map-map-directory">more...</a><div>
  </td>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>Map(const boost::filesystem::path & directory,</code><br>
   <code><script>nbsp(4)</script>const Options & options)</code>
   <div>Opens or creates a map in directory. <a href="#map-map-directory-options">more...</a><div>
  </td>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>~Map()</code>
   <div>Flushes all buffered data to disk, closes the map, and unlocks the directory where the map is located.<div>
  </td>
 </tr>
 <tr>
  <td><code>void</code></td>
  <td>
   <code>put(const Bytes & key, const Bytes & value)</code>
   <div>Appends value to the end of the list associated with the specified key. <a href="#map-put-range">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
   <code>template</code><br>
   <code>void</code>
  </td>
  <td>
   <code>&lt;typename InputIter&gt;</code><br>
   <code>put(const Bytes & key, InputIter first, InputIter last)</code>
   <div>Appends a range of values to the end of the list associated with the specified key. <a href="#map-put">more...</a><div>
  </td>
 </tr>
 <tr>
  <td><code>std::unique_ptr&lt;Iterator&gt;</code></td>
  <td>
   <code>get(const Bytes & key) const</code>
   <div>Returns a read-only iterator for the list associated with the specified key. <a href="#map-get">more...</a><div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>contains(const Bytes & key) const</code>
   <div>Returns true if there is at least one value associated with the specified key, false otherwise. <a href="#map-contains">more...</a><div>
  </td>
 </tr>
 <tr>
  <td><code>uint32_t</code></td>
  <td>
   <code>remove(const Bytes & key)</code>
   <div>Removes all values from the list associated with the specified key. <a href="#map-remove">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>bool</code>
  </td>
  <td>
   <code>removeFirstEqual(const Bytes & key, const Bytes & value)</code>
   <div>Removes the first value which is equal to the given one from the list associated with the specified key. <a href="#map-remove-first-equal">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>uint32_t</code>
  </td>
  <td>
   <code>removeAllEqual(const Bytes & key, const Bytes & value)</code>
   <div>Removes all values which are equal to the given one from the list associated with the specified key. <a href="#map-remove-all-equal">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>template</code><br>
    <code>bool</code>
  </td>
  <td>
   <code>&lt;typename Predicate&gt;</code><br>
   <code>removeFirstMatch(const Bytes & key, Predicate predicate)</code>
   <div>Removes the first value for which predicate yields true from the list associated with the specified key. <a href="#map-remove-first-match-key">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>template</code><br>
    <code>uint32_t</code>
  </td>
  <td>
   <code>&lt;typename Predicate&gt;</code><br>
   <code>removeFirstMatch(Predicate predicate)</code>
   <div>Removes all values from the list associated with the first key for which predicate yields true. <a href="#map-remove-first-match">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>template</code><br>
    <code>uint32_t</code>
  </td>
  <td>
   <code>&lt;typename Predicate&gt;</code><br>
   <code>removeAllMatches(const Bytes & key, Predicate predicate)</code>
   <div>Removes all values for which predicate yields true from the list associated with the specified key. <a href="#map-remove-all-matches-key">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>template</code><br>
    <code>std::pair&lt;uint32_t, uint64_t&gt;</code>
  </td>
  <td>
   <code>&lt;typename Predicate&gt;</code><br>
   <code>removeAllMatches(Predicate predicate)</code>
   <div>Removes all values from lists associated with keys for which predicate yields true. <a href="#map-remove-all-matches">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>bool</code>
  </td>
  <td>
   <code>replaceFirstEqual(const Bytes & key,</code><br>
   <code><script>nbsp(18)</script>const Bytes & old_value,</code><br>
   <code><script>nbsp(18)</script>const Bytes & new_value)</code>
   <div>Replaces the first value which is equal to old_value with new_value in the list associated with the specified key. <a href="#map-replace-first-equal">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>uint32_t</code>
  </td>
  <td>
   <code>replaceAllEqual(const Bytes & key,</code><br>
   <code><script>nbsp(16)</script>const Bytes & old_value,</code><br>
   <code><script>nbsp(16)</script>const Bytes & new_value)</code>
   <div>Replaces all values which are equal to old_value with new_value in the list associated with the specified key. <a href="#map-replace-all-equal">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>template</code><br>
    <code>bool</code>
  </td>
  <td>
   <code>&lt;typename Function&gt;</code><br>
   <code>replaceFirstMatch(const Bytes & key, Function map)</code>
   <div>Replaces the first value with the result of invoking map in the list associated with the specified key. A match is indicated if map returns a non-empty string for a given value. <a href="#map-replace-first-match">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>template</code><br>
    <code>uint32_t</code>
  </td>
  <td>
   <code>&lt;typename Function&gt;</code><br>
   <code>replaceAllMatches(const Bytes & key, Function map)</code>
   <div>Replaces all values with the result of invoking map in the list associated with the specified key. A match is indicated if map returns a non-empty string for a given value. <a href="#map-replace-all-matches">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>template</code><br>
    <code>void</code>
  </td>
  <td>
   <code>&lt;typename Procedure&gt;</code><br>
   <code>forEachKey(Procedure process) const</code>
   <div>Applies process to each key in the map. <a href="#map-for-each-key">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>template</code><br>
    <code>void</code>
  </td>
  <td>
   <code>&lt;typename Procedure&gt;</code><br>
   <code>forEachValue(const Bytes & key, Procedure process) const</code>
   <div>Applies process to each value in the list associated with the specified key. <a href="#map-for-each-value">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>template</code><br>
    <code>void</code>
  </td>
  <td>
   <code>&lt;typename BinaryProcedure&gt;</code><br>
   <code>forEachEntry(BinaryProcedure process) const</code>
   <div>Applies process to each key-iterator pair. <a href="#map-for-each-entry">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>std::vector&lt;Stats&gt;</code>
  </td>
  <td>
   <code>getStats() const</code>
   <div>Returns statistical information about each partition of the map. <a href="#map-get-stats">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>Stats</code>
  </td>
  <td>
   <code>getTotalStats() const</code>
   <div>Returns statistical information about the map. <a href="#map-get-total-stats">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>bool</code>
  </td>
  <td>
   <code>isReadOnly() const</code>
   <div>Returns true if the map is read-only, false otherwise.<div>
  </td>
 </tr>
 <tr>
  <th colspan="2">Static member functions</th>
 </tr>
 <tr>
  <td>
    <code>std::vector&lt;Stats&gt;</code>
  </td>
  <td>
   <code>stats(const boost::filesystem::path & directory)</code>
   <div>Returns statistical information about each partition of the map located in directory. <a href="#map-stats">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>void</code>
  </td>
  <td>
   <code>importFromBase64(const boost::filesystem::path & directory,</code><br>
   <code><script>nbsp(17)</script>const boost::filesystem::path & input)</code>
   <div>Imports key-value pairs from an input file or directory into the map located in directory. <a href="#map-import-from-base64">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>void</code>
  </td>
  <td>
   <code>importFromBase64(const boost::filesystem::path & directory,</code><br>
   <code><script>nbsp(17)</script>const boost::filesystem::path & input)</code><br>
   <code><script>nbsp(17)</script>const Options & options)</code>
   <div>Same as before, but gives the user more control by providing an <a href="#struct-mapoptions">Options</a> parameter which is passed to the constructor of Map when opening. This way a map can be created if it does not already exist. <a href="#map-map-directory-options">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>void</code>
  </td>
  <td>
   <code>exportToBase64(const boost::filesystem::path & directory,</code><br>
   <code><script>nbsp(15)</script>const boost::filesystem::path & output)</code>
   <div>Exports all key-value pairs from the map located in directory to a file denoted by output. <a href="#map-export-to-base64">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>void</code>
  </td>
  <td>
   <code>exportToBase64(const boost::filesystem::path & directory,</code><br>
   <code><script>nbsp(15)</script>const boost::filesystem::path & output,</code><br>
   <code><script>nbsp(15)</script>const Options & options)</code>
   <div>Same as before, but gives the user more control by providing an <a href="#struct-mapoptions">Options</a> parameter. Most users will use this to pass a compare function that triggers a sorting of all lists before exporting them.<div>
  </td>
 </tr>
 <tr>
  <td>
    <code>void</code>
  </td>
  <td>
   <code>optimize(const boost::filesystem::path & directory,</code><br>
   <code><script>nbsp(9)</script>const boost::filesystem::path & output)</code>
   <div>Rewrites the map located in directory to the directory denoted by output performing various optimizations. <a href="#map-optimize">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>void</code>
  </td>
  <td>
   <code>optimize(const boost::filesystem::path & directory,</code><br>
   <code><script>nbsp(9)</script>const boost::filesystem::path & output,</code><br>
   <code><script>nbsp(9)</script>const Options & options)</code>
   <div>Same as before, but gives the user more control by providing an <a href="#struct-mapoptions">Options</a> parameter. Most users will use this to pass a compare function that triggers a sorting of all lists.<div>
  </td>
 </tr>
</tbody>
</table>

<div class="reference-more">
 <h4 id="map-map-directory"><code>explicit Map::Map(const boost::filesystem::path & directory)</code></h4>
 <p>Opens an already existing map located in directory.</p>
 <p><span class="acquires" />a <a href="../overview/#directory-lock">directory lock</a> on directory.</p>
 <p><span class="throws" /><a href="http://en.cppreference.com/w/cpp/error/runtime_error">std::runtime_error</a> if one of the following is true:</p>
 <ul>
  <li>the directory does not exist</li>
  <li>the directory cannot be locked</li>
  <li>the directory does not contain a map</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-map-directory-options">
  <code>Map::Map(const boost::filesystem::path & directory,</code><br>
  <code><script>nbsp(9)</script>const <a href="#struct-mapoptions">Options</a> & options)</code>
 </h4>
 <p>Opens or creates a map in directory. For the latter, you need to set <code>options.create_if_missing = true</code>. If an error should be raised in case the map already exists, set <code>options.error_if_exists = true</code>. When a new map is created other fields in options are used to configure the map's block size and number of partitions. See <a href="#struct-mapoptions">Options</a> for more information.</p>
 <p><span class="acquires" />a <a href="../overview/#directory-lock">directory lock</a> on directory.</p>
 <p><span class="throws" /><a href="http://en.cppreference.com/w/cpp/error/runtime_error">std::runtime_error</a> if one of the following is true:</p>
 <ul>
  <li>the directory does not exist</li>
  <li>the directory cannot be locked</li>
 </ul>
 <p>when <code>options.create_if_missing = false</code> (which is the default)</p>
 <ul>
  <li>the directory does not contain a map</li>
 </ul>
 <p>when <code>options.create_if_missing = true</code> and no map exists</p>
 <ul>
  <li><code>options.block_size</code> is zero</li>
  <li><code>options.block_size</code> is not a power of two</li>
  <li><code>options.buffer_size</code> is not a multiple of the block size</li>
 </ul>
 <p>when <code>options.error_if_exists = true</code></p>
 <ul>
  <li>the directory already contains a map</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-put"><code>void Map::put(const Bytes & key, const Bytes & value)</code></h4>
 <p>Appends value to the end of the list associated with the specified key.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#writer-lock">writer lock</a> on the map object.</li>
  <li>a <a href="../overview/#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="throws" /><a href="http://en.cppreference.com/w/cpp/error/runtime_error">std::runtime_error</a> if one of the following is true:</p>
 <ul>
  <li><code>key.size() > Map::Limits::maxKeySize()</code></li>
  <li><code>value.size() > Map::Limits::maxValueSize()</code></li>
  <li>the map was opened in read-only mode</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-put-range">
  <code>template &lt;typename InputIter&gt;</code><br>
  <code>void Map::put(const Bytes & key, InputIter first, InputIter last)</code></h4>
 <p>Appends a range of values to the end of the list associated with the specified key.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#writer-lock">writer lock</a> on the map object.</li>
  <li>a <a href="../overview/#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="throws" /><a href="http://en.cppreference.com/w/cpp/error/runtime_error">std::runtime_error</a> if one of the following is true:</p>
 <ul>
  <li><code>key.size() > Map::Limits::maxKeySize()</code></li>
  <li><code>value.size() > Map::Limits::maxValueSize()</code> for any value in the range</li>
  <li>the map was opened in read-only mode</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-get"><code>std::unique_ptr&lt;<a href="#class-iterator">Iterator</a>&gt; Map::get(const Bytes & key) const</code></h4>
 <p>Returns a read-only iterator for the list associated with the specified key. If the key does not exist, an empty iterator that has no values is returned. A non-empty iterator owns a reader lock on the associated list that is released automatically when the lifetime of the iterator ends.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the list associated with key.</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-contains"><code>bool Map::contains(const Bytes & key) const</code></h4>
 <p>Returns true if there is at least one value associated with the specified key, false otherwise.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the list associated with key.</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-remove"><code>uint32_t Map::remove(const Bytes & key)</code></h4>
 <p>Removes all values from the list associated with the specified key.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="../overview/#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="returns" />the number of values that have been removed.</p>
</div>

<div class="reference-more">
 <h4 id="map-remove-first-equal">
  <code>bool Map::removeFirstEqual(const Bytes & key, const Bytes & value)</code>
 </h4>
 <p>Removes the first value which is equal to the given one from the list associated with the specified key.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="../overview/#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="returns" />true if a value has been removed, false otherwise.</p>
</div>

<div class="reference-more">
 <h4 id="map-remove-all-equal">
  <code>uint32_t Map::removeAllEqual(const Bytes & key, const Bytes & value)</code>
 </h4>
 <p>Removes all values which are equal to the given one from the list associated with the specified key.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="../overview/#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="returns" />the number of values that have been removed.</p>
</div>

<div class="reference-more">
 <h4 id="map-remove-first-match-key">
  <code>template &lt;typename <a href="#predicate">Predicate</a>&gt;</code><br>
  <code>bool Map::removeFirstMatch(const Bytes & key, Predicate predicate)</code>
 </h4>
 <p>Removes the first value for which predicate yields true from the list associated with the specified key.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="../overview/#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="returns" />true if a value has been removed, false otherwise.</p>
</div>

<div class="reference-more">
 <h4 id="map-remove-first-match">
  <code>template &lt;typename <a href="#predicate">Predicate</a>&gt;</code><br>
  <code>uint32_t Map::removeFirstMatch(Predicate predicate)</code>
 </h4>
 <p>Removes all values from the list associated with the first key for which predicate yields true.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="../overview/#writer-lock">writer lock</a> on the list associated with the matching key.</li>
 </ul>
 <p><span class="returns" />the number of values that have been removed.</p>
</div>

<div class="reference-more">
 <h4 id="map-remove-all-matches-key">
  <code>template &lt;typename <a href="#predicate">Predicate</a>&gt;</code><br>
  <code>uint32_t Map::removeAllMatches(const Bytes & key, Predicate predicate)</code>
 </h4>
 <p>Removes the first value for which predicate yields true from the list associated with the specified key.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="../overview/#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="returns" />the number of values that have been removed.</p>
</div>

<div class="reference-more">
 <h4 id="map-remove-all-matches">
  <code>template &lt;typename <a href="#predicate">Predicate</a>&gt;</code><br>
  <code>std::pair&lt;uint32_t, uint64_t&gt; Map::removeAllMatches(Predicate predicate)</code>
 </h4>
 <p>Removes all values from lists associated with keys for which predicate yields true.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="../overview/#writer-lock">writer lock</a> on lists associated with matching keys.</li>
 </ul>
 <p><span class="returns" />a pair whose first element tells the number of keys and the second element the total number of values that have been removed.</p>
</div>

<div class="reference-more">
 <h4 id="map-replace-first-equal">
  <code>bool Map::replaceFirstEqual(const Bytes & key, </code><br>
  <code><script>nbsp(28)</script>const Bytes & old_value,</code><br>
  <code><script>nbsp(28)</script>const Bytes & new_value)</code>
 </h4>
 <p>Replaces the first value which is equal to old_value with new_value in the list associated with the specified key.</p>
 <p>Note that a replace operation is actually implemented in terms of a remove of the old value followed by an insert/put of the new value. Hence, the new value is always the last value in the list. In other words, the replacement is not in-place.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="../overview/#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="returns" />true if a value has been replaced, false otherwise.</p>
</div>

<div class="reference-more">
 <h4 id="map-replace-all-equal">
  <code>uint32_t Map::replaceAllEqual(const Bytes & key, </code><br>
  <code><script>nbsp(30)</script>const Bytes & old_value,</code><br>
  <code><script>nbsp(30)</script>const Bytes & new_value)</code>
 </h4>
 <p>Replaces all values which are equal to old_value with new_value in the list associated with the specified key.</p>
 <p>Note that a replace operation is actually implemented in terms of a remove of the old value followed by an insert/put of the new value. Thus, the new value is always the last value in the list. In other words, the replacement is not in-place.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="../overview/#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="returns" />the number of values that have been replaced.</p>
</div>

<div class="reference-more">
 <h4 id="map-replace-first-match">
  <code>template &lt;typename <a href="#function">Function</a>&gt;</code><br>
  <code>bool Map::replaceFirstMatch(const Bytes & key, Function map)</code>
 </h4>
 <p>Replaces the first value with the result of invoking map in the list associated with the specified key. A match is indicated by returning a non-empty string from map for a given value.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="../overview/#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="returns" />true if a value has been replaced, false otherwise.</p>
</div>

<div class="reference-more">
 <h4 id="map-replace-all-matches">
  <code>template &lt;typename <a href="#function">Function</a>&gt;</code><br>
  <code>uint32_t Map::replaceAllMatches(const Bytes & key, Function map)</code>
 </h4>
 <p>Replaces all values with the result of invoking map in the list associated with the specified key. A match is indicated by returning a non-empty string from map for a given value.</p>
 <p>Note that a replace operation is actually implemented in terms of a remove of the old value followed by an insert/put of the new value. Thus, the new value is always the last value in the list. In other words, the replacement is not in-place.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="../overview/#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="returns" />the number of values that have been replaced.</p>
</div>

<div class="reference-more">
 <h4 id="map-for-each-key">
  <code>template &lt;typename <a href="#procedure">Procedure</a>&gt;</code><br>
  <code>void Map::forEachKey(Procedure process) const</code>
 </h4>
 <p>Applies process to each key in the map.</p>
 <p><span class="acquires" />a <a href="../overview/#reader-lock">reader lock</a> on the map object.</p>
</div>

<div class="reference-more">
 <h4 id="map-for-each-value">
  <code>template &lt;typename <a href="#procedure">Procedure</a>&gt;</code><br>
  <code>void Map::forEachValue(const Bytes & key, Procedure process) const</code>
 </h4>
 <p>Applies process to each value in the list associated with the specified key.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the list associated with key.</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-for-each-entry">
  <code>template &lt;typename <a href="#binaryprocedure">BinaryProcedure</a>&gt;</code><br>
  <code>void Map::forEachEntry(BinaryProcedure process) const</code>
 </h4>
 <p>Applies process to each key-iterator pair.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the list that is currently processed.</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-get-stats">
  <code>std::vector&lt;<a href="#type-mapstats">Map::Stats</a>&gt; Map::getStats() const</code>
 </h4>
 <p>Returns statistical information about each partition of the map. This operation requires a traversal of the entire map visiting each entry.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the list that is currently visited.</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-get-total-stats">
  <code><a href="#type-mapstats">Map::Stats</a> Map::getTotalStats() const</code>
 </h4>
 <p>Returns statistical information about the map. In fact, this method computes the total values from the result returned by calling the previous method.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="../overview/#reader-lock">reader lock</a> on the list that is currently visited.</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-stats">
  <code>static std::vector&lt;<a href="#type-mapstats">Map::Stats</a>&gt; Map::stats(</code><br>
  <code><script>nbsp(8)</script>const boost::filesystem::path & directory)</code>
 </h4>
 <p>Returns statistical information about each partition of the map located in directory. This method is similar to <a href="#map-get-stats">Map::getStats()</a> except that the map does not need to be instantiated.</p>
 <p><span class="acquires" />a <a href="../overview/#directory-lock">directory lock</a> on directory.</p>
 <p><span class="throws" /><a href="http://en.cppreference.com/w/cpp/error/runtime_error">std::runtime_error</a> if one of the following is true:</p>
 <ul>
  <li>the directory does not exist</li>
  <li>the directory cannot be locked</li>
  <li>the directory does not contain a map</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-import-from-base64">
  <code>static void Map::importFromBase64(</code><br>
  <code><script>nbsp(8)</script>const boost::filesystem::path & directory,</code><br>
  <code><script>nbsp(8)</script>const boost::filesystem::path & input)</code>
 </h4>
 <p>Imports key-value pairs from an input file or directory into the map located in directory. If input refers to a directory all files in that directory will be imported, except hidden files starting with a dot and other sub-directories. A description of the file format can be found in the <a href="../overview/#multimap-import">overview</a> section.</p>
 <p><span class="acquires" />a <a href="../overview/#directory-lock">directory lock</a> on directory.</p>
 <p><span class="throws" /> everything thrown by the constructor of class <a href="#class-map">Map</a> or <a href="http://en.cppreference.com/w/cpp/error/runtime_error">std::runtime_error</a> if the input file or directory cannot be read.</p>
</div>

<div class="reference-more">
 <h4 id="map-export-to-base64">
  <code>static void Map::exportToBase64(</code><br>
  <code><script>nbsp(8)</script>const boost::filesystem::path & directory,</code><br>
  <code><script>nbsp(8)</script>const boost::filesystem::path & output)</code>
 </h4>
 <p>Exports all key-value pairs from the map located in directory to a file denoted by output. If the file already exists, its content will be overwritten. The generated file is in canonical form as described in the <a href="../overview/#multimap-export">overview</a> section.</p>
 <p><span class="acquires" />a <a href="../overview/#directory-lock">directory lock</a> on directory.</p>
 <p><span class="throws" /><a href="http://en.cppreference.com/w/cpp/error/runtime_error">std::runtime_error</a> if one of the following is true:</p>
 <ul>
  <li>the directory does not exist</li>
  <li>the directory cannot be locked</li>
  <li>the directory does not contain a map</li>
  <li>the creation of the output file failed</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-optimize">
  <code>static void Map::optimize(</code><br>
  <code><script>nbsp(8)</script>const boost::filesystem::path & directory,</code><br>
  <code><script>nbsp(8)</script>const boost::filesystem::path & output)</code>
 </h4>
 <p>Rewrites the map located in directory to the directory denoted by output performing various optimizations. For more details please refer to the <a href="../overview/#multimap-optimize">overview</a> section.</p>
 <p><span class="acquires" />a <a href="../overview/#directory-lock">directory lock</a> on directory.</p>
 <p><span class="throws" /><a href="http://en.cppreference.com/w/cpp/error/runtime_error">std::runtime_error</a> if one of the following is true:</p>
 <ul>
  <li>the directory does not exist</li>
  <li>the directory cannot be locked</li>
  <li>the directory does not contain a map</li>
  <li>the creation of a new map in output failed</li>
 </ul>
</div>

<h3 id="struct-maplimits">struct Map::Limits</h3>
<p>This type represents a namespace that provides static methods for obtaining system limitations. Those limits which define constraints on user supplied data also serve as preconditions.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Static member functions</th>
 </tr>
 <tr>
  <td><code>uint32_t</code></td>
  <td>
   <code>maxKeySize()</code>
   <div>Returns the maximum size in number of bytes for a key to put.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint32_t</code></td>
  <td>
   <code>maxValueSize()</code>
   <div>Returns the maximum size in number of bytes for a value to put.<div>
  </td>
 </tr>
</tbody>
</table>

<h3 id="struct-mapoptions">struct Map::Options</h3>
<p>This class is a pure data holder used for configuration purposes.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Data members</th>
 </tr>
 <tr>
  <td><code>uint32_t</code></td>
  <td>
   <code>block_size</code>
   <div>Defines the block size in number of bytes for a newly created map or partition. The value must be a power of two. Typical block sizes are 128, 256, 512 (default), 1024, or even larger. Please refer to the <a href="../overview/#block-organization">overview</a> section for more details.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint32_t</code></td>
  <td>
   <code>num_partitions</code>
   <div>Defines the number of partitions for a newly created map. The purpose of partitioning is to increase the performance of the <a href="../overview/#multimap-export">export</a> and <a href="../overview/#multimap-optimize">optimize</a> operations by applying a divide and conquer method. A suitable number can be estimated like this: "total number of value-bytes to be put" divided by "the memory allowed to be used running the operation". An underestimate can lead to long runtimes for the mentioned operations. The default value is 23; other values will be rounded to the next prime number that is greater or equal to the given value.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint32_t</code></td>
  <td>
   <code>buffer_size</code>
   <div>Defines the size of an internal buffer that contains blocks to be written. The default value is 1 MiB; other values are required to be a multiple of the given block size. Most users should leave this parameter alone.<div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>create_if_missing</code>
   <div>If set to true, creates a new map if it does not exist. The default value is false.<div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>error_if_exists</code>
   <div>If set to true, throws an exception if a map already exists. The default value is false.<div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>readonly</code>
   <div>If set to true, opens a map in read-only mode. In this mode all operations that could possibly modify the stored data are not allowed and will throw an exception on an attempt to do so. This flag is useful to prevent unintentional updates of read-only datasets. The default value is false.<div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>quiet</code>
   <div>If set to true, no status information for long running operations are sent to stdout. This flag is useful for writing shell scripts. The default value is false.<div>
  </td>
 </tr>
 <tr>
  <td><code>Compare</code></td>
  <td>
   <code>compare</code>
   <div>A callable that implements the <a href="#compare">Compare</a> interface. It is used to sort lists of values when running certain operations such as <a href="../overview/#multimap-export">export</a> or <a href="../overview/#multimap-optimize">optimize</a>. Actually this member is a <a href="http://en.cppreference.com/w/cpp/utility/functional/function">function wrapper</a>, not a generic type, which can be left empty (default) if no sorting is desired.<div>
  </td>
 </tr>
 <tr>
  <th colspan="2">Member functions</th>
 </tr>
 <tr>
  <td><code>void</code></td>
  <td>
   <code>keepNumPartitions()</code>
   <div>Sets <code>num_partitions</code> to a special value that indicates to the <a href="../overview/#multimap-optimize">optimize</a> operation that the number of partitions should not be changed. <div>
  </td>
 </tr>
 <tr>
  <td><code>void</code></td>
  <td>
   <code>keepBlockSize()</code>
   <div>Sets <code>block_size</code> to a special value that indicates to the <a href="../overview/#multimap-optimize">optimize</a> operation that the block size should not be changed.<div>
  </td>
 </tr>
</tbody>
</table>

<h3 id="struct-mapstats">struct Map::Stats</h3>
<p>This type is a pure data holder for reporting statistical information.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Data members</th>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>block_size</code>
   <div>Tells the block size of the map or partition which was defined in <a href="#struct-mapoptions">Options</a> when creating the map.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>key_size_avg</code>
   <div>Tells the average size in number of bytes of all keys in a map or partition. Note that keys that are currently not associated with any value are not taken into account.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>key_size_max</code>
   <div>Tells the size in number of bytes of the largest key in a map or partition.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>key_size_min</code>
   <div>Tells the size in number of bytes of the smallest key in a map or partition.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>list_size_avg</code>
   <div>Tells the average number of values associated with a key in a map or partition. Note that keys that are currently not associated with any value are not taken into account.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>list_size_max</code>
   <div>Tells the largest number of values associated with a key in a map or partition.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>list_size_min</code>
   <div>Tells the smallest number of values associated with a key in a map or partition. Note that keys that are currently not associated with any value are not taken into account.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>num_blocks</code>
   <div>Tells the number of blocks currently written to disk. Note that in-memory write buffer blocks that are associated with each keys are not taken into account. For more details please refer to the <a href="../overview/#block-organization">overview</a> section.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>num_keys_total</code>
   <div>Tells the total number of keys in a map or partition, including keys that are currently not associated with any value.
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>num_keys_valid</code>
   <div>Tells the number of valid keys in a map or partition. A valid key is associated with at least one value.
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>num_values_total</code>
   <div>Tells the total number of values in a map or partition, including values that are marked as removed. Note that this number can only be decreased by running an <a href="../overview/#multimap-optimize">optimize</a> operation.
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>num_values_valid</code>
   <div>Tells the number of values in a map or partition that are not marked as removed.</div>
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>num_partitions</code>
   <div>Tells the number of partitions in a map. The value could be different from that specified in options when creating a map due to the fact that the next prime number has been chosen. For partition-specific statistics the value is set to 0.</div>
  </td>
 </tr>
</tbody>
</table>

<h2 id="interfaces">Interfaces</h2>
<p>The interfaces described here are requirements expected by some user-provided function objects. They are typically employed as template parameters and are not to be confused with abstract classes used in object-oriented programming. Sometimes this type of interfaces is also referred to as <a href="http://en.cppreference.com/w/cpp/concept">Concepts</a>.</p>
<h3 id="compare">Compare</h3>
<p>A callable that is applied to two instances of class <a href="#class-bytes">Bytes</a> returning a boolean that tells if the left operand is less than the right operand. This interface is equivalent to the Compare concept described <a href="http://en.cppreference.com/w/cpp/concept/Compare">here</a>. Objects implementing this interface are typically used by sorting algorithms.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Required member function</th>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>operator()(const Bytes & lhs, const Bytes & rhs) const</code>
   <div>Returns true if lhs is considered less than rhs, false otherwise.<div>
  </td>
 </tr>
</tbody>
</table>

<h3 id="function">Function</h3>
<p>A callable that is applied to an instance of class <a href="#class-bytes">Bytes</a> returning a standard string. The returned string serves as a managed byte buffer and may contain arbitrary data. Objects implementing this interface are typically used for mapping input values to output values in replace operations.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Required member function</th>
 </tr>
 <tr>
  <td><code>std::string</code></td>
  <td>
   <code>operator()(const Bytes & bytes) const</code>
   <div>Maps the given byte array to another byte array returned as standard string.<div>
  </td>
 </tr>
</tbody>
</table>

<h3 id="predicate">Predicate</h3>
<p>A callable that is applied to an instance of class <a href="#class-bytes">Bytes</a> returning a boolean value. Objects implementing this interface are typically used to qualify keys or values for some further operation.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Required member function</th>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>operator()(const Bytes & bytes) const</code>
   <div>Returns a boolean value after evaluating the given byte array.<div>
  </td>
 </tr>
</tbody>
</table>

<h3 id="procedure">Procedure</h3>
<p>A callable that is applied to an instance of class <a href="#class-bytes">Bytes</a> without returning any value. Procedures may maintain an internal state that changes during application. Objects implementing this interface are typically used to visit keys or values, e.g. to collect information about them.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Required member function</th>
 </tr>
 <tr>
  <td><code>void</code></td>
  <td>
   <code>operator()(const Bytes & bytes)</code>
   <div>Processes the given byte array, possibly changing the callable's state.<div>
  </td>
 </tr>
</tbody>
</table>

<h3 id="binaryprocedure">BinaryProcedure</h3>
<p>A callable that takes two arguments and does not return a value. The first argument being an instance of class <a href="#class-bytes">Bytes</a> and the second argument being a pointer to an object implementing the <a href="#class-iterator">Iterator</a> interface. Binary procedures may maintain an internal state that changes during application. Objects implementing this interface are typically used to visit entries when traversing a map.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Required member function</th>
 </tr>
 <tr>
  <td><code>void</code></td>
  <td>
   <code>operator()(const Bytes & key, Iterator * iterator)</code>
   <div>Processes the list associated with key, possibly changing the callable's state. The lifetime of the given iterator ends when the function has terminated. Do not keep a copy of the pointer in the callable's state.<div>
  </td>
 </tr>
</tbody>
</table>
              </div>
              <div class="col-md-3" role="complementary">
                <nav id="multimap-sidebar"
                     class="hidden-print hidden-xs hidden-sm affix-top"
                     data-spy="affix" data-offset-top="130" data-offset-bottom="200">
                  <ul class="nav">
                    
                      <li><a href="#byteshpp">Bytes.hpp</a>
                        <ul>
                          
                          <li><a href="#class-bytes">class Bytes</a></li>
                          
                        </ul>
                      </li>
                    
                      <li><a href="#iteratorhpp">Iterator.hpp</a>
                        <ul>
                          
                          <li><a href="#class-iterator">class Iterator</a></li>
                          
                        </ul>
                      </li>
                    
                      <li><a href="#maphpp">Map.hpp</a>
                        <ul>
                          
                          <li><a href="#class-map">class Map</a></li>
                          
                          <li><a href="#struct-maplimits">struct Map::Limits</a></li>
                          
                          <li><a href="#struct-mapoptions">struct Map::Options</a></li>
                          
                          <li><a href="#struct-mapstats">struct Map::Stats</a></li>
                          
                        </ul>
                      </li>
                    
                      <li><a href="#interfaces">Interfaces</a>
                        <ul>
                          
                          <li><a href="#compare">Compare</a></li>
                          
                          <li><a href="#function">Function</a></li>
                          
                          <li><a href="#predicate">Predicate</a></li>
                          
                          <li><a href="#procedure">Procedure</a></li>
                          
                          <li><a href="#binaryprocedure">BinaryProcedure</a></li>
                          
                        </ul>
                      </li>
                    
                  </ul>
                  <div id="back-to-top">
                    <a href="#top">Back to top</a>
                  </div>
                </nav>
              </div>
            
          </div>
        </div>
        <br>
        <br>
        <br>
      
    </div>
    
    <footer id="footer">
      <div class="container">
        <a href="http://www.gnu.org/licenses/agpl-3.0.en.html" target="_blank">
          <img style="float:right" src="../img/agpl-v3-logo-white-on-gray.png" />
        </a>
        <p>
          <i class="fa fa-copyright"></i> 2015-<script>year()</script> by <a href="https://github.com/mtrenkmann">Martin Trenkmann</a>
        </p>
        <p>Documentation built with <a href="http://getbootstrap.com/">Bootstrap</a>
          &middot; <a href="http://www.tipo.net.ar/">Faster One</a>
          &middot; <a href="http://www.carrois.com/fira-4-1/">Fira</a>
          &middot; <a href="http://fontawesome.io/">Font Awesome</a>
          &middot; <a href="https://highlightjs.org/">highlight.js</a>
          &middot; <a href="https://daringfireball.net/projects/markdown/">Markdown</a>
          &middot; <a href="http://www.mkdocs.org/">MkDocs</a></p>
      </div>
    </footer>
  </body>
</html>
